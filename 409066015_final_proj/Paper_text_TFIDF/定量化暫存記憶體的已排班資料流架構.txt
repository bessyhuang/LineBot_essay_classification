定量化暫存記憶體的已排班資料流架構
Scalability of Scheduled Dataflow with Register Context
在這篇論文我們提出一個新的想法：多工緒已排班的資料料流架構(SDF)，這是一個建構於資料流(Dataflow)、無法中斷的多工緒(Non-blocking Multi-thread)以及執行與記憶體分離(Decoupled memory access)的架構。當一個程式在此架構上執行時，程式會被分割成許多無法中斷的緒而且這些緒將不會再執行的時間裡，作任何的記憶體存取。程式所需要的資料會被先載入緒所被配置的暫存器(Register set)，然後執行完畢再存入記憶體。我們知道暫存器是最快但是最貴的記憶體裝置，所以電腦中是不可能擁有無限的暫存器，因此我們只好利用記憶體來替代存取資料。在這篇論文中我們提到，當系統擁有足夠的暫存器供程式使用時，則將配置足夠的暫存器給程式以利執行效能，但是當系統的暫存器不敷使用時，我們則利用一套機制去判別那些的緒將配置暫存器，而那些緒將被配置到記憶體。我們去比較當系統擁有無限暫存器時的效能，和系統只配置有限個暫存器時的效能差異。我們將會把這樣的結果在這篇論文中作呈現，並且做出當程式不需要太多的暫存器時，事實上多的暫存器只是浪費資源，並不會有更高的效能這樣的結論。
In this research we have been exploring some new characteristics of Scheduled Dataflow architecture. This architecture is based on dataflow, non-blocking multithread and decoupling of memory access from the execution pipeline. A program is partitioned into many non-blocking threads and all memory accesses are completely decoupled from the thread’s execution. Data is preloaded into thread’s contexts (registers), and all the results are post-stored after the completion of the thread’s execution. Previously this architecture has been explored by few to show that the execution cycles of this unique architecture outperform the MIPS like control flow architecture. It is different from pure dataflow architecture, where the instructions are scheduled like control flow architecture. Hence, its name scheduled dataflow architecture. In any architecture, we can not have unlimited register sets. In this particular research we have been focusing on exploring the limited register sets and the speedup based on the limited register sets as well as unlimited register sets. The code has been developed to check every code block to see if the thread has a register set during run time. If the thread has no register set available at the time of allocation, it would be allocated a frame pointer and the thread has to load the data from its related frame pointer at the time of preload phase. If sufficient number of register sets is available, then a register set will be allocated for the related thread. If a thread has a register set while running, if it needs the data from the previous thread to start the non-blocking thread to proceed, then the previous thread can store its result in the related registers instead of storing into the frame memory. Thus, the thread need not have a pre-load phase. In order to prove how many register sets would be sufficient to obtain optimal performance improvement, several experiments were conducted and the results are presented in cycle counts.
